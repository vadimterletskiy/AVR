
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000334  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000003a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000006a  00800060  00800060  000003a8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000003a8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000003d8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000b0  00000000  00000000  00000414  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000544  00000000  00000000  000004c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000344  00000000  00000000  00000a08  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000003c7  00000000  00000000  00000d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000180  00000000  00000000  00001114  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000027d  00000000  00000000  00001294  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000412  00000000  00000000  00001511  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  00001923  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	21 c0       	rjmp	.+66     	; 0x46 <__bad_interrupt>
   4:	20 c0       	rjmp	.+64     	; 0x46 <__bad_interrupt>
   6:	84 c0       	rjmp	.+264    	; 0x110 <__vector_3>
   8:	1e c0       	rjmp	.+60     	; 0x46 <__bad_interrupt>
   a:	1d c0       	rjmp	.+58     	; 0x46 <__bad_interrupt>
   c:	1c c0       	rjmp	.+56     	; 0x46 <__bad_interrupt>
   e:	1b c0       	rjmp	.+54     	; 0x46 <__bad_interrupt>
  10:	1a c0       	rjmp	.+52     	; 0x46 <__bad_interrupt>
  12:	19 c0       	rjmp	.+50     	; 0x46 <__bad_interrupt>
  14:	18 c0       	rjmp	.+48     	; 0x46 <__bad_interrupt>
  16:	17 c0       	rjmp	.+46     	; 0x46 <__bad_interrupt>
  18:	16 c0       	rjmp	.+44     	; 0x46 <__bad_interrupt>
  1a:	15 c0       	rjmp	.+42     	; 0x46 <__bad_interrupt>
  1c:	14 c0       	rjmp	.+40     	; 0x46 <__bad_interrupt>
  1e:	13 c0       	rjmp	.+38     	; 0x46 <__bad_interrupt>
  20:	12 c0       	rjmp	.+36     	; 0x46 <__bad_interrupt>
  22:	11 c0       	rjmp	.+34     	; 0x46 <__bad_interrupt>
  24:	10 c0       	rjmp	.+32     	; 0x46 <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_clear_bss>:
  32:	20 e0       	ldi	r18, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	01 c0       	rjmp	.+2      	; 0x3c <.do_clear_bss_start>

0000003a <.do_clear_bss_loop>:
  3a:	1d 92       	st	X+, r1

0000003c <.do_clear_bss_start>:
  3c:	aa 3c       	cpi	r26, 0xCA	; 202
  3e:	b2 07       	cpc	r27, r18
  40:	e1 f7       	brne	.-8      	; 0x3a <.do_clear_bss_loop>
  42:	02 d0       	rcall	.+4      	; 0x48 <main>
  44:	75 c1       	rjmp	.+746    	; 0x330 <_exit>

00000046 <__bad_interrupt>:
  46:	dc cf       	rjmp	.-72     	; 0x0 <__vectors>

00000048 <main>:

#include "defines.h"

int main(void)
{
	InitRTOS();
  48:	18 d0       	rcall	.+48     	; 0x7a <InitRTOS>
	RunRTOS();
  4a:	69 d1       	rcall	.+722    	; 0x31e <RunRTOS>
__attribute__ ((__always_inline__))
void wdt_enable (const uint8_t value)
{
	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
	{
		__asm__ __volatile__ (
  4c:	9b e0       	ldi	r25, 0x0B	; 11
  4e:	88 e1       	ldi	r24, 0x18	; 24
  50:	0f b6       	in	r0, 0x3f	; 63
  52:	f8 94       	cli
  54:	a8 95       	wdr
  56:	81 bd       	out	0x21, r24	; 33
  58:	0f be       	out	0x3f, r0	; 63
  5a:	91 bd       	out	0x21, r25	; 33
	wdt_enable(WDTO_120MS);
	SetTask(TaskLedOn);
  5c:	84 e3       	ldi	r24, 0x34	; 52
  5e:	90 e0       	ldi	r25, 0x00	; 0
  60:	2f d0       	rcall	.+94     	; 0xc0 <SetTask>
    while (1) 
    {
      wdt_reset();	// Сброс собачьего таймера
  62:	a8 95       	wdr
      TaskManager();	// Вызов диспетчера
  64:	2f d1       	rcall	.+606    	; 0x2c4 <TaskManager>
    }
  66:	fd cf       	rjmp	.-6      	; 0x62 <main+0x1a>

00000068 <TaskLedOn>:
 */ 
#include "defines.h"

void TaskLedOn (void)
{
	SetTimerTask(TaskLedOn,10);
  68:	6a e0       	ldi	r22, 0x0A	; 10
  6a:	70 e0       	ldi	r23, 0x00	; 0
  6c:	84 e3       	ldi	r24, 0x34	; 52
  6e:	90 e0       	ldi	r25, 0x00	; 0
  70:	b5 d0       	rcall	.+362    	; 0x1dc <SetTimerTask>
	PORTB = 0x05;
  72:	85 e0       	ldi	r24, 0x05	; 5
  74:	88 bb       	out	0x18, r24	; 24
  76:	08 95       	ret

00000078 <Idle>:
*/
inline void TimerService(void)
{
uint8_t index;

for(index=0;index!=MainTimerQueueSize+1;index++)		// Прочесываем очередь таймеров
  78:	08 95       	ret

0000007a <InitRTOS>:
  7a:	80 e0       	ldi	r24, 0x00	; 0
		{
		SetTask(MainTimer[index].GoToTask);				// Дощелкали до нуля? Пихаем в очередь задачу
		MainTimer[index].GoToTask = Idle;				// А в ячейку пишем затычку
		}
	}
}
  7c:	90 e0       	ldi	r25, 0x00	; 0
  7e:	2c e3       	ldi	r18, 0x3C	; 60
  80:	30 e0       	ldi	r19, 0x00	; 0
  82:	fc 01       	movw	r30, r24
  84:	ee 0f       	add	r30, r30
  86:	ff 1f       	adc	r31, r31
  88:	e0 56       	subi	r30, 0x60	; 96
{
uint8_t  	index;

for(index=0;index!=TaskQueueSize+1;index++)	// Во все позиции записываем Idle
	{
	TaskQueue[index] = Idle;
  8a:	ff 4f       	sbci	r31, 0xFF	; 255
  8c:	31 83       	std	Z+1, r19	; 0x01
  8e:	20 83       	st	Z, r18
  90:	01 96       	adiw	r24, 0x01	; 1
// RTOS Подготовка. Очистка очередей
inline void InitRTOS(void)
{
uint8_t  	index;

for(index=0;index!=TaskQueueSize+1;index++)	// Во все позиции записываем Idle
  92:	85 31       	cpi	r24, 0x15	; 21
  94:	91 05       	cpc	r25, r1
  96:	a9 f7       	brne	.-22     	; 0x82 <InitRTOS+0x8>
  98:	80 e0       	ldi	r24, 0x00	; 0
  9a:	90 e0       	ldi	r25, 0x00	; 0
	}


for(index=0;index!=MainTimerQueueSize+1;index++) // Обнуляем все таймеры.
	{
	MainTimer[index].GoToTask = Idle;
  9c:	2c e3       	ldi	r18, 0x3C	; 60
  9e:	30 e0       	ldi	r19, 0x00	; 0
  a0:	fc 01       	movw	r30, r24
  a2:	ee 0f       	add	r30, r30
  a4:	ff 1f       	adc	r31, r31
  a6:	ee 0f       	add	r30, r30
  a8:	ff 1f       	adc	r31, r31
  aa:	e0 5a       	subi	r30, 0xA0	; 160
  ac:	ff 4f       	sbci	r31, 0xFF	; 255
  ae:	31 83       	std	Z+1, r19	; 0x01
  b0:	20 83       	st	Z, r18
	MainTimer[index].Time = 0;
  b2:	13 82       	std	Z+3, r1	; 0x03
  b4:	12 82       	std	Z+2, r1	; 0x02
  b6:	01 96       	adiw	r24, 0x01	; 1
	{
	TaskQueue[index] = Idle;
	}


for(index=0;index!=MainTimerQueueSize+1;index++) // Обнуляем все таймеры.
  b8:	80 31       	cpi	r24, 0x10	; 16
  ba:	91 05       	cpc	r25, r1
  bc:	89 f7       	brne	.-30     	; 0xa0 <InitRTOS+0x26>
	{
	MainTimer[index].GoToTask = Idle;
	MainTimer[index].Time = 0;
	}
}
  be:	08 95       	ret

000000c0 <SetTask>:
{

uint8_t		index = 0;
uint8_t		nointerrupted = 0;

if (STATUS_REG & (1<<Interrupt_Flag))  // Если прерывания разрешены, то запрещаем их.
  c0:	0f b6       	in	r0, 0x3f	; 63
  c2:	07 fe       	sbrs	r0, 7
  c4:	0c c0       	rjmp	.+24     	; 0xde <SetTask+0x1e>
	{
	Disable_Interrupt
  c6:	f8 94       	cli
	nointerrupted = 1;					// И ставим флаг, что мы не в прерывании. 
  c8:	a1 e0       	ldi	r26, 0x01	; 1
  ca:	0a c0       	rjmp	.+20     	; 0xe0 <SetTask+0x20>
  cc:	2f 5f       	subi	r18, 0xFF	; 255
  ce:	3f 4f       	sbci	r19, 0xFF	; 255
	}

while(TaskQueue[index]!=Idle) 			// Прочесываем очередь задач на предмет свободной ячейки
	{									// с значением Idle - конец очереди.
	index++;
	if (index==TaskQueueSize+1) 		// Если очередь переполнена то выходим не солоно хлебавши
  d0:	25 31       	cpi	r18, 0x15	; 21
  d2:	31 05       	cpc	r19, r1
  d4:	39 f4       	brne	.+14     	; 0xe4 <SetTask+0x24>
		{
		if (nointerrupted)	Enable_Interrupt 	// Если мы не в прерывании, то разрешаем прерывания
  d6:	aa 23       	and	r26, r26
  d8:	d1 f0       	breq	.+52     	; 0x10e <SetTask+0x4e>
  da:	78 94       	sei
  dc:	08 95       	ret
// Отдаваемое значение - код ошибки.
void SetTask(TPTR TS)
{

uint8_t		index = 0;
uint8_t		nointerrupted = 0;
  de:	a0 e0       	ldi	r26, 0x00	; 0
  e0:	20 e0       	ldi	r18, 0x00	; 0
  e2:	30 e0       	ldi	r19, 0x00	; 0
	{
	Disable_Interrupt
	nointerrupted = 1;					// И ставим флаг, что мы не в прерывании. 
	}

while(TaskQueue[index]!=Idle) 			// Прочесываем очередь задач на предмет свободной ячейки
  e4:	b9 01       	movw	r22, r18
  e6:	f9 01       	movw	r30, r18
  e8:	ee 0f       	add	r30, r30
  ea:	ff 1f       	adc	r31, r31
  ec:	e0 56       	subi	r30, 0x60	; 96
  ee:	ff 4f       	sbci	r31, 0xFF	; 255
  f0:	40 81       	ld	r20, Z
  f2:	51 81       	ldd	r21, Z+1	; 0x01
  f4:	4c 53       	subi	r20, 0x3C	; 60
  f6:	50 40       	sbci	r21, 0x00	; 0
  f8:	49 f7       	brne	.-46     	; 0xcc <SetTask+0xc>
		if (nointerrupted)	Enable_Interrupt 	// Если мы не в прерывании, то разрешаем прерывания
		return;									// Раньше функция возвращала код ошибки - очередь переполнена. Пока убрал.
		}
	}
												// Если нашли свободное место, то
TaskQueue[index] = TS;							// Записываем в очередь задачу
  fa:	66 0f       	add	r22, r22
  fc:	77 1f       	adc	r23, r23
  fe:	fb 01       	movw	r30, r22
 100:	e0 56       	subi	r30, 0x60	; 96
 102:	ff 4f       	sbci	r31, 0xFF	; 255
 104:	91 83       	std	Z+1, r25	; 0x01
 106:	80 83       	st	Z, r24
if (nointerrupted) Enable_Interrupt				// И включаем прерывания если не в обработчике прерывания.
 108:	aa 23       	and	r26, r26
 10a:	09 f0       	breq	.+2      	; 0x10e <SetTask+0x4e>
 10c:	78 94       	sei
 10e:	08 95       	ret

00000110 <__vector_3>:
#include "EERTOS.h"
#include <stdint-gcc.h>

// RTOS Interrupt
ISR(RTOS_ISR) { TimerService();}
 110:	1f 92       	push	r1
 112:	0f 92       	push	r0
 114:	0f b6       	in	r0, 0x3f	; 63
 116:	0f 92       	push	r0
 118:	11 24       	eor	r1, r1
 11a:	ef 92       	push	r14
 11c:	ff 92       	push	r15
 11e:	0f 93       	push	r16
 120:	1f 93       	push	r17
 122:	2f 93       	push	r18
 124:	3f 93       	push	r19
 126:	4f 93       	push	r20
 128:	5f 93       	push	r21
 12a:	6f 93       	push	r22
 12c:	7f 93       	push	r23
 12e:	8f 93       	push	r24
 130:	9f 93       	push	r25
 132:	af 93       	push	r26
 134:	bf 93       	push	r27
 136:	cf 93       	push	r28
 138:	df 93       	push	r29
 13a:	ef 93       	push	r30
 13c:	ff 93       	push	r31
 13e:	e1 2c       	mov	r14, r1
 140:	f1 2c       	mov	r15, r1
		MainTimer[index].Time --;						// Уменьшаем число в ячейке если не конец.
		}
	else
		{
		SetTask(MainTimer[index].GoToTask);				// Дощелкали до нуля? Пихаем в очередь задачу
		MainTimer[index].GoToTask = Idle;				// А в ячейку пишем затычку
 142:	0c e3       	ldi	r16, 0x3C	; 60
 144:	10 e0       	ldi	r17, 0x00	; 0
{
uint8_t index;

for(index=0;index!=MainTimerQueueSize+1;index++)		// Прочесываем очередь таймеров
	{
	if(MainTimer[index].GoToTask == Idle) continue;		// Если нашли пустышку - щелкаем следующую итерацию
 146:	f7 01       	movw	r30, r14
 148:	d7 01       	movw	r26, r14
 14a:	aa 0f       	add	r26, r26
 14c:	bb 1f       	adc	r27, r27
 14e:	aa 0f       	add	r26, r26
 150:	bb 1f       	adc	r27, r27
 152:	a0 5a       	subi	r26, 0xA0	; 160
 154:	bf 4f       	sbci	r27, 0xFF	; 255
 156:	8d 91       	ld	r24, X+
 158:	9c 91       	ld	r25, X
 15a:	8c 53       	subi	r24, 0x3C	; 60
 15c:	90 40       	sbci	r25, 0x00	; 0
 15e:	01 f1       	breq	.+64     	; 0x1a0 <__vector_3+0x90>

	if(MainTimer[index].Time !=1)						// Если таймер не выщелкал, то щелкаем еще раз. 
 160:	d7 01       	movw	r26, r14
 162:	aa 0f       	add	r26, r26
 164:	bb 1f       	adc	r27, r27
 166:	aa 0f       	add	r26, r26
 168:	bb 1f       	adc	r27, r27
 16a:	a0 5a       	subi	r26, 0xA0	; 160
 16c:	bf 4f       	sbci	r27, 0xFF	; 255
 16e:	12 96       	adiw	r26, 0x02	; 2
 170:	8d 91       	ld	r24, X+
 172:	9c 91       	ld	r25, X
 174:	13 97       	sbiw	r26, 0x03	; 3
 176:	01 97       	sbiw	r24, 0x01	; 1
 178:	39 f0       	breq	.+14     	; 0x188 <__vector_3+0x78>
		{												// To Do: Вычислить по тактам, что лучше !=1 или !=0. 
		MainTimer[index].Time --;						// Уменьшаем число в ячейке если не конец.
 17a:	fd 01       	movw	r30, r26
 17c:	82 81       	ldd	r24, Z+2	; 0x02
 17e:	93 81       	ldd	r25, Z+3	; 0x03
 180:	01 97       	sbiw	r24, 0x01	; 1
 182:	93 83       	std	Z+3, r25	; 0x03
 184:	82 83       	std	Z+2, r24	; 0x02
 186:	0c c0       	rjmp	.+24     	; 0x1a0 <__vector_3+0x90>
		}
	else
		{
		SetTask(MainTimer[index].GoToTask);				// Дощелкали до нуля? Пихаем в очередь задачу
 188:	ee 0f       	add	r30, r30
 18a:	ff 1f       	adc	r31, r31
 18c:	ee 0f       	add	r30, r30
 18e:	ff 1f       	adc	r31, r31
 190:	ef 01       	movw	r28, r30
 192:	c0 5a       	subi	r28, 0xA0	; 160
 194:	df 4f       	sbci	r29, 0xFF	; 255
 196:	88 81       	ld	r24, Y
 198:	99 81       	ldd	r25, Y+1	; 0x01
 19a:	92 df       	rcall	.-220    	; 0xc0 <SetTask>
		MainTimer[index].GoToTask = Idle;				// А в ячейку пишем затычку
 19c:	19 83       	std	Y+1, r17	; 0x01
 19e:	08 83       	st	Y, r16
 1a0:	8f ef       	ldi	r24, 0xFF	; 255
 1a2:	e8 1a       	sub	r14, r24
 1a4:	f8 0a       	sbc	r15, r24
*/
inline void TimerService(void)
{
uint8_t index;

for(index=0;index!=MainTimerQueueSize+1;index++)		// Прочесываем очередь таймеров
 1a6:	20 e1       	ldi	r18, 0x10	; 16
 1a8:	e2 16       	cp	r14, r18
 1aa:	f1 04       	cpc	r15, r1
 1ac:	61 f6       	brne	.-104    	; 0x146 <__vector_3+0x36>
#include "EERTOS.h"
#include <stdint-gcc.h>

// RTOS Interrupt
ISR(RTOS_ISR) { TimerService();}
 1ae:	ff 91       	pop	r31
 1b0:	ef 91       	pop	r30
 1b2:	df 91       	pop	r29
 1b4:	cf 91       	pop	r28
 1b6:	bf 91       	pop	r27
 1b8:	af 91       	pop	r26
 1ba:	9f 91       	pop	r25
 1bc:	8f 91       	pop	r24
 1be:	7f 91       	pop	r23
 1c0:	6f 91       	pop	r22
 1c2:	5f 91       	pop	r21
 1c4:	4f 91       	pop	r20
 1c6:	3f 91       	pop	r19
 1c8:	2f 91       	pop	r18
 1ca:	1f 91       	pop	r17
 1cc:	0f 91       	pop	r16
 1ce:	ff 90       	pop	r15
 1d0:	ef 90       	pop	r14
 1d2:	0f 90       	pop	r0
 1d4:	0f be       	out	0x3f, r0	; 63
 1d6:	0f 90       	pop	r0
 1d8:	1f 90       	pop	r1
 1da:	18 95       	reti

000001dc <SetTimerTask>:
void SetTimerTask(TPTR TS, uint16_t NewTime)
{
uint16_t		index=0;
uint16_t		nointerrupted = 0;

if (STATUS_REG & (1<<Interrupt_Flag)) 			// Проверка запрета прерывания, аналогично функции выше
 1dc:	0f b6       	in	r0, 0x3f	; 63
 1de:	07 fe       	sbrs	r0, 7
 1e0:	66 c0       	rjmp	.+204    	; 0x2ae <SetTimerTask+0xd2>
	{
	Disable_Interrupt
 1e2:	f8 94       	cli
	}


for(index=0;index!=MainTimerQueueSize+1;++index)	//Прочесываем очередь таймеров
	{
	if(MainTimer[index].GoToTask == TS)				// Если уже есть запись с таким адресом
 1e4:	20 91 60 00 	lds	r18, 0x0060
 1e8:	30 91 61 00 	lds	r19, 0x0061
 1ec:	28 17       	cp	r18, r24
 1ee:	39 07       	cpc	r19, r25
 1f0:	09 f4       	brne	.+2      	; 0x1f4 <SetTimerTask+0x18>
 1f2:	53 c0       	rjmp	.+166    	; 0x29a <SetTimerTask+0xbe>
uint16_t		nointerrupted = 0;

if (STATUS_REG & (1<<Interrupt_Flag)) 			// Проверка запрета прерывания, аналогично функции выше
	{
	Disable_Interrupt
	nointerrupted = 1;
 1f4:	41 e0       	ldi	r20, 0x01	; 1
 1f6:	50 e0       	ldi	r21, 0x00	; 0
 1f8:	1b c0       	rjmp	.+54     	; 0x230 <SetTimerTask+0x54>
	}


for(index=0;index!=MainTimerQueueSize+1;++index)	//Прочесываем очередь таймеров
	{
	if(MainTimer[index].GoToTask == TS)				// Если уже есть запись с таким адресом
 1fa:	f9 01       	movw	r30, r18
 1fc:	ee 0f       	add	r30, r30
 1fe:	ff 1f       	adc	r31, r31
 200:	ee 0f       	add	r30, r30
 202:	ff 1f       	adc	r31, r31
 204:	e0 5a       	subi	r30, 0xA0	; 160
 206:	ff 4f       	sbci	r31, 0xFF	; 255
 208:	01 90       	ld	r0, Z+
 20a:	f0 81       	ld	r31, Z
 20c:	e0 2d       	mov	r30, r0
 20e:	e8 17       	cp	r30, r24
 210:	f9 07       	cpc	r31, r25
 212:	81 f4       	brne	.+32     	; 0x234 <SetTimerTask+0x58>
		{
		MainTimer[index].Time = NewTime;			// Перезаписываем ей выдержку
 214:	22 0f       	add	r18, r18
 216:	33 1f       	adc	r19, r19
 218:	22 0f       	add	r18, r18
 21a:	33 1f       	adc	r19, r19
 21c:	f9 01       	movw	r30, r18
 21e:	e0 5a       	subi	r30, 0xA0	; 160
 220:	ff 4f       	sbci	r31, 0xFF	; 255
 222:	73 83       	std	Z+3, r23	; 0x03
 224:	62 83       	std	Z+2, r22	; 0x02
		if (nointerrupted) 	Enable_Interrupt		// Разрешаем прерывания если не были запрещены.
 226:	45 2b       	or	r20, r21
 228:	09 f4       	brne	.+2      	; 0x22c <SetTimerTask+0x50>
 22a:	4b c0       	rjmp	.+150    	; 0x2c2 <SetTimerTask+0xe6>
 22c:	78 94       	sei
 22e:	08 95       	ret
uint16_t		nointerrupted = 0;

if (STATUS_REG & (1<<Interrupt_Flag)) 			// Проверка запрета прерывания, аналогично функции выше
	{
	Disable_Interrupt
	nointerrupted = 1;
 230:	20 e0       	ldi	r18, 0x00	; 0
 232:	30 e0       	ldi	r19, 0x00	; 0
	}


for(index=0;index!=MainTimerQueueSize+1;++index)	//Прочесываем очередь таймеров
 234:	2f 5f       	subi	r18, 0xFF	; 255
 236:	3f 4f       	sbci	r19, 0xFF	; 255
 238:	20 31       	cpi	r18, 0x10	; 16
 23a:	31 05       	cpc	r19, r1
 23c:	f1 f6       	brne	.-68     	; 0x1fa <SetTimerTask+0x1e>
	}
	

for(index=0;index!=MainTimerQueueSize+1;++index)	// Если не находим похожий таймер, то ищем любой пустой	
	{
	if (MainTimer[index].GoToTask == Idle)		
 23e:	20 91 60 00 	lds	r18, 0x0060
 242:	30 91 61 00 	lds	r19, 0x0061
 246:	2c 53       	subi	r18, 0x3C	; 60
 248:	30 40       	sbci	r19, 0x00	; 0
 24a:	81 f0       	breq	.+32     	; 0x26c <SetTimerTask+0x90>
 24c:	21 e0       	ldi	r18, 0x01	; 1
 24e:	30 e0       	ldi	r19, 0x00	; 0
 250:	f9 01       	movw	r30, r18
 252:	ee 0f       	add	r30, r30
 254:	ff 1f       	adc	r31, r31
 256:	ee 0f       	add	r30, r30
 258:	ff 1f       	adc	r31, r31
 25a:	e0 5a       	subi	r30, 0xA0	; 160
 25c:	ff 4f       	sbci	r31, 0xFF	; 255
 25e:	01 90       	ld	r0, Z+
 260:	f0 81       	ld	r31, Z
 262:	e0 2d       	mov	r30, r0
 264:	ec 53       	subi	r30, 0x3C	; 60
 266:	f0 40       	sbci	r31, 0x00	; 0
 268:	91 f4       	brne	.+36     	; 0x28e <SetTimerTask+0xb2>
 26a:	02 c0       	rjmp	.+4      	; 0x270 <SetTimerTask+0x94>
 26c:	20 e0       	ldi	r18, 0x00	; 0
 26e:	30 e0       	ldi	r19, 0x00	; 0
		{
		MainTimer[index].GoToTask = TS;			// Заполняем поле перехода задачи
 270:	22 0f       	add	r18, r18
 272:	33 1f       	adc	r19, r19
 274:	22 0f       	add	r18, r18
 276:	33 1f       	adc	r19, r19
 278:	f9 01       	movw	r30, r18
 27a:	e0 5a       	subi	r30, 0xA0	; 160
 27c:	ff 4f       	sbci	r31, 0xFF	; 255
 27e:	91 83       	std	Z+1, r25	; 0x01
 280:	80 83       	st	Z, r24
		MainTimer[index].Time = NewTime;		// И поле выдержки времени
 282:	73 83       	std	Z+3, r23	; 0x03
 284:	62 83       	std	Z+2, r22	; 0x02
		if (nointerrupted) 	Enable_Interrupt	// Разрешаем прерывания
 286:	45 2b       	or	r20, r21
 288:	e1 f0       	breq	.+56     	; 0x2c2 <SetTimerTask+0xe6>
 28a:	78 94       	sei
 28c:	08 95       	ret
		return;										// Выходим. Раньше был код успешной операции. Пока убрал
		}
	}
	

for(index=0;index!=MainTimerQueueSize+1;++index)	// Если не находим похожий таймер, то ищем любой пустой	
 28e:	2f 5f       	subi	r18, 0xFF	; 255
 290:	3f 4f       	sbci	r19, 0xFF	; 255
 292:	20 31       	cpi	r18, 0x10	; 16
 294:	31 05       	cpc	r19, r1
 296:	e1 f6       	brne	.-72     	; 0x250 <SetTimerTask+0x74>
 298:	08 95       	ret

for(index=0;index!=MainTimerQueueSize+1;++index)	//Прочесываем очередь таймеров
	{
	if(MainTimer[index].GoToTask == TS)				// Если уже есть запись с таким адресом
		{
		MainTimer[index].Time = NewTime;			// Перезаписываем ей выдержку
 29a:	70 93 63 00 	sts	0x0063, r23
 29e:	60 93 62 00 	sts	0x0062, r22
 2a2:	c4 cf       	rjmp	.-120    	; 0x22c <SetTimerTask+0x50>
 2a4:	70 93 63 00 	sts	0x0063, r23
 2a8:	60 93 62 00 	sts	0x0062, r22
 2ac:	08 95       	ret
	}


for(index=0;index!=MainTimerQueueSize+1;++index)	//Прочесываем очередь таймеров
	{
	if(MainTimer[index].GoToTask == TS)				// Если уже есть запись с таким адресом
 2ae:	20 91 60 00 	lds	r18, 0x0060
 2b2:	30 91 61 00 	lds	r19, 0x0061
 2b6:	28 17       	cp	r18, r24
 2b8:	39 07       	cpc	r19, r25
 2ba:	a1 f3       	breq	.-24     	; 0x2a4 <SetTimerTask+0xc8>
//Функция установки задачи по таймеру. Передаваемые параметры - указатель на функцию, 
// Время выдержки в тиках системного таймера. Возвращет код ошибки.
void SetTimerTask(TPTR TS, uint16_t NewTime)
{
uint16_t		index=0;
uint16_t		nointerrupted = 0;
 2bc:	40 e0       	ldi	r20, 0x00	; 0
 2be:	50 e0       	ldi	r21, 0x00	; 0
 2c0:	b7 cf       	rjmp	.-146    	; 0x230 <SetTimerTask+0x54>
 2c2:	08 95       	ret

000002c4 <TaskManager>:
/*=================================================================================
Диспетчер задач ОС. Выбирает из очереди задачи и отправляет на выполнение.
*/

inline void TaskManager(void)
{
 2c4:	cf 93       	push	r28
 2c6:	df 93       	push	r29
uint8_t		index=0;
TPTR	GoToTask = Idle;		// Инициализируем переменные

Disable_Interrupt				// Запрещаем прерывания!!!
 2c8:	f8 94       	cli
GoToTask = TaskQueue[0];		// Хватаем первое значение из очереди
 2ca:	e0 91 a0 00 	lds	r30, 0x00A0
 2ce:	f0 91 a1 00 	lds	r31, 0x00A1

if (GoToTask==Idle) 			// Если там пусто
 2d2:	80 e0       	ldi	r24, 0x00	; 0
 2d4:	ec 33       	cpi	r30, 0x3C	; 60
 2d6:	f8 07       	cpc	r31, r24
 2d8:	11 f4       	brne	.+4      	; 0x2de <TaskManager+0x1a>
	{
	Enable_Interrupt			// Разрешаем прерывания
 2da:	78 94       	sei
 2dc:	1d c0       	rjmp	.+58     	; 0x318 <TaskManager+0x54>
 2de:	80 e0       	ldi	r24, 0x00	; 0
 2e0:	90 e0       	ldi	r25, 0x00	; 0
	}
else
	{
	for(index=0;index!=TaskQueueSize;index++)	// В противном случае сдвигаем всю очередь
		{
		TaskQueue[index]=TaskQueue[index+1];
 2e2:	dc 01       	movw	r26, r24
 2e4:	01 96       	adiw	r24, 0x01	; 1
 2e6:	ec 01       	movw	r28, r24
 2e8:	cc 0f       	add	r28, r28
 2ea:	dd 1f       	adc	r29, r29
 2ec:	c0 56       	subi	r28, 0x60	; 96
 2ee:	df 4f       	sbci	r29, 0xFF	; 255
 2f0:	28 81       	ld	r18, Y
 2f2:	39 81       	ldd	r19, Y+1	; 0x01
 2f4:	aa 0f       	add	r26, r26
 2f6:	bb 1f       	adc	r27, r27
 2f8:	a0 56       	subi	r26, 0x60	; 96
 2fa:	bf 4f       	sbci	r27, 0xFF	; 255
 2fc:	11 96       	adiw	r26, 0x01	; 1
 2fe:	3c 93       	st	X, r19
 300:	2e 93       	st	-X, r18
	Enable_Interrupt			// Разрешаем прерывания
	(Idle)(); 					// Переходим на обработку пустого цикла
	}
else
	{
	for(index=0;index!=TaskQueueSize;index++)	// В противном случае сдвигаем всю очередь
 302:	84 31       	cpi	r24, 0x14	; 20
 304:	91 05       	cpc	r25, r1
 306:	69 f7       	brne	.-38     	; 0x2e2 <TaskManager+0x1e>
		{
		TaskQueue[index]=TaskQueue[index+1];
		}

	TaskQueue[TaskQueueSize]= Idle;				// В последнюю запись пихаем затычку
 308:	8c e3       	ldi	r24, 0x3C	; 60
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	90 93 c9 00 	sts	0x00C9, r25
 310:	80 93 c8 00 	sts	0x00C8, r24

	Enable_Interrupt							// Разрешаем прерывания
 314:	78 94       	sei
	(GoToTask)();								// Переходим к задаче
 316:	09 95       	icall
	}
}
 318:	df 91       	pop	r29
 31a:	cf 91       	pop	r28
 31c:	08 95       	ret

0000031e <RunRTOS>:
#include "EERTOSHAL.h"

//RTOS Запуск системного таймера
inline void RunRTOS (void)
{
TCCR2 = 1<<WGM21|4<<CS20; 				// Freq = CK/64 - Установить режим и предделитель
 31e:	8c e0       	ldi	r24, 0x0C	; 12
 320:	85 bd       	out	0x25, r24	; 37
										// Автосброс после достижения регистра сравнения
TCNT2 = 0;								// Установить начальное значение счётчиков
 322:	14 bc       	out	0x24, r1	; 36
OCR2  = LO(TimerDivider); 				// Установить значение в регистр сравнения
 324:	8c ea       	ldi	r24, 0xAC	; 172
 326:	83 bd       	out	0x23, r24	; 35
TIMSK = 0<<TOIE0|1<<OCF2|0<<TOIE0;		// Разрешаем прерывание RTOS - запуск ОС
 328:	80 e8       	ldi	r24, 0x80	; 128
 32a:	89 bf       	out	0x39, r24	; 57

sei();
 32c:	78 94       	sei
 32e:	08 95       	ret

00000330 <_exit>:
 330:	f8 94       	cli

00000332 <__stop_program>:
 332:	ff cf       	rjmp	.-2      	; 0x332 <__stop_program>
